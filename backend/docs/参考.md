# MRRA 雷达误差分析 - 关键模块详解

## 目录

1. [关键航迹提取](#一关键航迹提取)
2. [航迹插值存储](#二航迹插值存储)
3. [航迹匹配](#三航迹匹配)
4. [SQL表结构](#四sql表结构)

---

## 一、关键航迹提取

### 1.1 模块概述

**文件**: `src/track_extractor.py`

**目的**: 从原始雷达航迹数据中提取出**持续、稳定的关键航迹段**，过滤掉噪声和短暂出现的航迹点。

**核心思想**: 使用**空间网格 + 时间窗口**的方法，检测在特定区域内持续存在一定时间的航迹。

---

### 1.2 算法流程图

```
原始航迹数据
      │
      ▼
┌─────────────────────────────────────────┐
│  初始化空间网格 (分辨率: 0.2度)          │
│  self.data = 网格[经度][纬度] = 点列表   │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  按时间遍历 (0 ~ 86400秒)                │
│  每秒处理当前时间窗口内的点              │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  步骤1: 添加新点到网格                   │
│  - 计算网格坐标: grid_x, grid_y          │
│  - 将点存入 self.data[grid_x][grid_y]    │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  步骤2: 清理过期点                       │
│  - 移除时间 < current_time - 60秒的点    │
│  - 保持时间窗口滑动                      │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  步骤3: 检测3×3邻域内的关键点             │
│  对每个网格点(x,y):                      │
│    - 收集3×3邻域内所有点                 │
│    - 判断: 邻域点数 >= 5                 │
│    - 判断: 所有点来自同一雷达站          │
│    - 判断: 持续时间 >= 45秒 (60×0.75)    │
│    - 取中间点作为关键点                  │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  步骤4: 按批号分组                       │
│  将关键点按批号(track_id)分组           │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  步骤5: 分割连续航迹段                   │
│  - 检测时间间隔 > 100秒的断裂点          │
│  - 去掉首尾各2个点                       │
│  - 过滤: 段长度 >= 10点                 │
└─────────────────────────────────────────┘
      │
      ▼
   关键航迹段
```

---

### 1.3 核心代码详解

#### 1.3.1 空间网格初始化

```python
# track_extractor.py:22-42
class TrackExtractor:
    def __init__(self, min_coord: np.ndarray, max_coord: np.ndarray):
        """
        初始化航迹提取器

        Args:
            min_coord: 最小坐标 [经度, 纬度]
            max_coord: 最大坐标 [经度, 纬度]
        """
        # 计算网格维度
        self.min_xy = np.floor(min_coord / config.GRID_RESOLUTION).astype(np.int32)
        max_xy = np.ceil(max_coord / config.GRID_RESOLUTION).astype(np.int32) + 1

        self.dim = max_xy - self.min_xy          # 网格大小
        self.para1 = config.GRID_RESOLUTION      # 0.2度
        self.delay = config.TIME_WINDOW          # 60秒

        # 初始化二维网格: data[经度索引][纬度索引] = 点列表
        self.data = [[[] for _ in range(self.dim[1])] for _ in range(self.dim[0])]
        self.results = []                         # 存储提取的关键点
        self.processed_flags = set()              # 避免重复添加
```

**网格示意图**:

```
纬度 ↑
     │
     │  [0,0]  [1,0]  [2,0]  [3,0]  ...
     │  [0,1]  [1,1]  [2,1]  [3,1]
     │  [0,2]  [1,2]  [2,2]  [3,2]
     │  ...    ...    ...    ...
     │
     └───────────────────────────────→ 经度

每个网格单元存储一个点列表:
data[x][y] = [(批号, 时间, 经度, 纬度, 高度), ...]
```

---

#### 1.3.2 添加点与检测关键点

```python
# track_extractor.py:44-94
def add_points(self, current_time: int, points: List[Tuple]):
    """
    添加当前时间的航迹点并检测关键点

    Args:
        current_time: 当前时间（秒）
        points: 航迹点列表，格式为 (批号, 时间秒, 经度, 纬度, 高度, ...)
    """
    # ========== 步骤1: 添加新点 ==========
    for point in points:
        # 计算网格坐标
        grid_x, grid_y = np.round(np.array(point[2:4]) / self.para1).astype(np.int32) - self.min_xy

        # 确保在网格范围内
        if 0 <= grid_x < self.dim[0] and 0 <= grid_y < self.dim[1]:
            self.data[grid_x][grid_y].append(point)

    # ========== 步骤2: 清理过期点 ==========
    for row in self.data:
        for cell in row:
            # 移除超过时间窗口的点 (FIFO队列)
            while cell and cell[0][1] < current_time - self.delay:
                cell.pop(0)

    # ========== 步骤3: 检测3×3邻域内的关键点 ==========
    for x in range(1, self.dim[0] - 2):
        for y in range(1, self.dim[1] - 2):
            # 收集3×3邻域内的所有点
            neighborhood = (
                self.data[x-1][y-1] + self.data[x-1][y] + self.data[x-1][y+1] +
                self.data[x][y-1]   + self.data[x][y]   + self.data[x][y+1]   +
                self.data[x+1][y-1] + self.data[x+1][y] + self.data[x+1][y+1]
            )

            # 判断条件1: 邻域内至少5个点
            if len(neighborhood) < 5:
                continue

            # 判断条件2: 所有点来自同一雷达站
            if len(set([p[0] for p in neighborhood])) == 1:
                # 按时间排序
                sorted_points = sorted(neighborhood, key=lambda p: p[1])

                # 判断条件3: 持续时间 >= 时间窗口 × 0.75 (即45秒)
                time_span = sorted_points[-1][1] - sorted_points[0][1]
                if time_span >= self.delay * config.TIME_WINDOW_RATIO:
                    # 取中间点作为关键点
                    key_point = sorted_points[len(sorted_points) // 2]
                    point_key = tuple(key_point[:2])  # (批号, 时间)

                    # 避免重复添加
                    if point_key not in self.processed_flags:
                        self.processed_flags.add(point_key)
                        self.results.append(key_point)
```

**3×3邻域检测示意图**:

```
        邻域 (3×3)
    ┌───┬───┬───┬───┬───┐
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │   │ ↑ │ ↑ │ ↑ │   │
    ├───┼───┼───┼───┼───┤
    │   │ ← │ ★ │ → │   │    ★ = 中心网格 (x,y)
    ├───┼───┼───┼───┼───┤    ↑←★→↓ = 3×3邻域
    │   │   │   │   │   │
    ├───┼───┼───┼───┼───┤
    │   │   │   │   │   │
    └───┴───┴───┴───┴───┘

判断逻辑:
1. 邻域内点总数 >= 5
2. 所有点的批号相同 (同一雷达站)
3. 时间跨度 >= 45秒
4. 取中间点作为关键点
```

---

#### 1.3.3 航迹段分割

```python
# track_extractor.py:159-182
# 按批号分组
track_groups = defaultdict(list)
for point in key_points:
    track_id = point[0]
    track_groups[track_id].append(point)

# 分割连续航迹段
for track_id, track_points in track_groups.items():
    if len(track_points) > 2:
        # 计算时间间隔
        times = np.array([p[1] for p in track_points])
        time_gaps = (times[1:] - times[:-1]) > 100  # 间隔>100秒视为断裂

        # 找到分割点
        split_indices = [0] + list(np.where(time_gaps)[0] + 1) + [len(times)]

        # 创建航迹段（去掉首尾各2个点）
        for i in range(len(split_indices) - 1):
            start_idx = split_indices[i] + 2      # 跳过开头2个点
            end_idx = split_indices[i + 1] - 1    # 跳过结尾1个点

            if end_idx > start_idx and (end_idx - start_idx) >= config.MIN_TRACK_POINTS:
                track_segment = track_points[start_idx:end_idx]
                all_key_tracks[station_id].append((track_id, track_segment))
```

**a示意图**:

```
原始关键点 (按时间排序):
时间:  0s ---- 50s ---- 100s ---- 300s ---- 350s ---- 400s
点:    P1       P2       P3        P4        P5        P6
       └────────┘        └────────────────┘
       连续段1 (间隔<100s)      连续段2

去掉首尾各2个点后:
段1: 无 (只有3个点，去掉首尾后不足)
段2: [P4, P5, P6] -> 去掉P4,P5各2个... 实际: P5,P6部分

过滤: 段长度 >= 10点才保留
```

---

### 1.4 关键参数说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `GRID_RESOLUTION` | 0.2度 | 空间网格分辨率，约22km |
| `TIME_WINDOW` | 60秒 | 时间窗口大小 |
| `TIME_WINDOW_RATIO` | 0.75 | 持续时间比例 (60×0.75=45秒) |
| `MIN_TRACK_POINTS` | 10 | 最小航迹点数 |

---

## 二、航迹插值存储

### 2.1 模块概述

**文件**: `src/track_interpolator.py`

**目的**: 对提取的关键航迹段进行**时间插值**，生成密集的时空点序列，并存储到SQLite数据库。

**核心思想**: 使用**线性插值**，在两个原始点之间的每个整数时间点生成新的插值点。

---

### 2.2 算法流程图

```
关键航迹段 (稀疏点)
      │
      ▼
┌─────────────────────────────────────────┐
│  输入: 航迹段点列表                      │
│  [(批号, 时间, 经度, 纬度, 高度), ...]   │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  对每个相邻点对:                         │
│  point_a = (t0, lon0, lat0, alt0)       │
│  point_b = (t1, lon1, lat1, alt1)       │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  计算速度向量:                           │
│  time_diff = t1 - t0                     │
│  velocity = ((lon1-lon0)/time_diff,     │
│              (lat1-lat0)/time_diff,     │
│              (alt1-alt0)/time_diff)     │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  在每个整数时间点插值:                   │
│  for t in (t0+1, t0+2, ..., t1):        │
│    pos = pos0 + velocity × (t - t0)     │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  生成插值点列表                          │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  存储到SQLite数据库                      │
│  rf_tb0: 原始点表                        │
│  rf_tb1: 插值点表                        │
└─────────────────────────────────────────┘
```

---

### 2.3 核心代码详解

#### 2.3.1 线性插值算法

```python
# track_interpolator.py:17-71
def interpolate_track_segment(
    station_id: int,
    track_id: int,
    segment_points: List[Tuple],
    segment_index: int
) -> Tuple[List[List], List[List]]:
    """
    对航迹段进行时间插值

    Args:
        station_id: 雷达站号
        track_id: 航迹批号
        segment_points: 航迹段点列表
        segment_index: 航迹段索引

    Returns:
        (原始点列表, 插值点列表)
    """
    original_points = []
    interpolated_points = []

    # ========== 保存原始点 ==========
    for point in segment_points:
        original_points.append([
            station_id,   # 站号
            point[0],     # 批号
            point[1],     # 时间秒
            point[2],     # 经度
            point[3],     # 纬度
            point[4],     # 高度
            segment_index # 段索引
        ])

    # ========== 插值处理 ==========
    prev_point = np.array(segment_points[0])
    interpolated_points.append([...])  # 添加第一个点

    for current_point in segment_points[1:]:
        current_point_np = np.array(current_point)

        # 计算速度向量 (经度/秒, 纬度/秒, 高度/秒)
        time_diff = current_point_np[1] - prev_point[1]
        if time_diff > 0:
            velocity = (current_point_np[2:] - prev_point[2:]) / time_diff

            # 在每个整数时间点插值
            for t in np.arange(prev_point[1] + 1, current_point_np[1] + 0.1):
                # 线性插值公式: pos = pos0 + v × (t - t0)
                interpolated_position = prev_point[2:] + velocity * (t - prev_point[1])
                interpolated_points.append([
                    station_id,
                    current_point_np[0],  # 批号
                    t,                    # 插值时间
                    interpolated_position[0],  # 插值经度
                    interpolated_position[1],  # 插值纬度
                    interpolated_position[2],  # 插值高度
                    segment_index
                ])

        prev_point = current_point_np

    return original_points, interpolated_points
```

**插值示意图**:

```
原始点: (t0=100s, lon=116.00) ---- (t1=105s, lon=116.05)
       点A                            点B

速度计算:
time_diff = 105 - 100 = 5秒
velocity = (116.05 - 116.00) / 5 = 0.01 度/秒

插值结果:
t=101s: lon = 116.00 + 0.01 × (101-100) = 116.01
t=102s: lon = 116.00 + 0.01 × (102-100) = 116.02
t=103s: lon = 116.00 + 0.01 × (103-100) = 116.03
t=104s: lon = 116.00 + 0.01 × (104-100) = 116.04

时间轴:
100s ── 101s ── 102s ── 103s ── 104s ── 105s
 A    插值1   插值2   插值3   插值4    B
```

---

#### 2.3.2 数据库存储

```python
# track_interpolator.py:74-158
def save_to_database(
    original_points: List[List],
    interpolated_points: List[List],
    db_file: str = None
):
    """
    将点数据保存到SQLite数据库
    """
    # 连接到数据库
    connection = sqlite3.connect(db_file)
    cursor = connection.cursor()

    # ========== 删除已存在的表 ==========
    cursor.execute('DROP TABLE IF EXISTS rf_tb0')
    cursor.execute('DROP TABLE IF EXISTS rf_tb1')

    # ========== 创建新表 ==========
    cursor.execute('''
        CREATE TABLE rf_tb0 (
            station_id INTEGER,      -- 雷达站号
            track_id INTEGER,        -- 航迹批号
            time_seconds REAL,       -- 时间(秒)
            longitude REAL,          -- 经度
            latitude REAL,           -- 纬度
            altitude REAL,           -- 高度
            segment_index INTEGER    -- 航迹段索引
        )
    ''')

    cursor.execute('''
        CREATE TABLE rf_tb1 (
            -- 与rf_tb0相同结构
            station_id INTEGER,
            track_id INTEGER,
            time_seconds REAL,
            longitude REAL,
            latitude REAL,
            altitude REAL,
            segment_index INTEGER
        )
    ''')

    # ========== 插入原始点数据 ==========
    for point in original_points:
        cursor.execute(
            'INSERT INTO rf_tb0 VALUES (?, ?, ?, ?, ?, ?, ?)',
            point
        )

    # ========== 插入插值点数据 ==========
    for point in interpolated_points:
        cursor.execute(
            'INSERT INTO rf_tb1 VALUES (?, ?, ?, ?, ?, ?, ?)',
            point
        )

    # ========== 创建索引 ==========
    cursor.execute('CREATE INDEX idx_rf_tb0_time ON rf_tb0(time_seconds)')
    cursor.execute('CREATE INDEX idx_rf_tb1_time ON rf_tb1(time_seconds)')
    cursor.execute('CREATE INDEX idx_rf_tb0_station ON rf_tb0(station_id)')
    cursor.execute('CREATE INDEX idx_rf_tb1_station ON rf_tb1(station_id)')

    connection.commit()
    connection.close()
```

---

### 2.4 为什么需要插值？

**原因**:

1. **时间对齐**: 不同雷达的采样时间可能不同，插值后可以在相同时间点进行比较
2. **增加匹配机会**: 更密集的点序列增加不同雷达航迹匹配的概率
3. **平滑航迹**: 插值可以填充原始数据中的时间间隙

**示例**:

```
雷达A: 100s, 105s, 110s (采样间隔5秒)
雷达B: 102s, 107s, 112s (采样间隔5秒，但时间偏移)

插值后:
雷达A: 100s, 101s, 102s, 103s, 104s, 105s, ...
雷达B: 102s, 103s, 104s, 105s, 106s, 107s, ...

现在可以在102s、103s等相同时间点进行匹配！
```

---

## 三、航迹匹配

### 3.1 模块概述

**文件**: `src/track_matcher.py`

**目的**: 找出不同雷达观测到的**同一个目标**，形成"匹配组"。

**核心思想**: 如果不同雷达在**相近时间**观测到**相近位置**的点，则认为它们观测的是同一个目标。

---

### 3.2 算法流程图

```
从数据库加载原始点和插值点
      │
      ▼
┌─────────────────────────────────────────┐
│  初始化匹配器 (创建空间网格)             │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  按时间遍历 (0 ~ 86400秒)                │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  收集当前时间的点:                       │
│  points_a = 原始点 (time <= current)    │
│  points_b = 插值点 (time <= current)    │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  对每个点_a，寻找匹配的点_b:              │
│  1. 同站号的点不匹配                     │
│  2. 计算空间距离                         │
│  3. 距离 < 阈值(0.12度) 则匹配成功       │
└─────────────────────────────────────────┘
      │
      ▼
┌─────────────────────────────────────────┐
│  形成匹配组:                             │
│  [点_a, 点_b1, 点_b2, ...]              │
│  至少2个点(来自不同雷达)才保留           │
└─────────────────────────────────────────┘
      │
      ▼
   匹配组列表
```

---

### 3.3 核心代码详解

```python
# track_matcher.py:44-98
def match_points(
    self,
    current_time: int,
    points_a: List[Tuple],
    points_b: List[Tuple]
) -> List[List[Tuple]]:
    """
    匹配两个点集

    Args:
        current_time: 当前时间（秒）
        points_a: 第一个点集 (原始点)
        points_b: 第二个点集 (插值点)

    Returns:
        匹配组列表，每个匹配组包含多个匹配点
    """
    matched_groups = []
    processed_pairs = set()  # 记录已处理的点，避免重复

    # ========== 处理点集A中的每个点 ==========
    for point_a in points_a:
        point_key = (point_a[0], point_a[1])  # (站号, 批号)

        # 跳过已处理的点
        if point_key in processed_pairs:
            continue

        processed_pairs.add(point_key)
        current_group = [point_a]

        # ========== 在点集B中寻找匹配点 ==========
        for point_b in points_b:
            point_b_key = (point_b[0], point_b[1])

            # 跳过已处理的点
            if point_b_key in processed_pairs:
                continue

            # 同站号的点不匹配 (同一雷达的点)
            if point_b[0] in [p[0] for p in current_group]:
                continue

            # ========== 计算空间距离 ==========
            point_a_coord = np.array(point_a[3:5])  # (经度, 纬度)
            point_b_coord = np.array(point_b[3:5])
            distance = np.sqrt(np.sum((point_b_coord - point_a_coord) ** 2))

            # ========== 检查是否在阈值内 ==========
            if distance < config.MATCH_DISTANCE_THRESHOLD:  # 0.12度
                current_group.append(point_b)
                processed_pairs.add(point_b_key)

        # ========== 只有匹配到至少2个点才保留 ==========
        if len(current_group) > 1:
            matched_groups.append(current_group)

    return matched_groups
```

**匹配示意图**:

```
时刻 t = 3600秒

空间分布:
        雷达1001观测点A
            ★
        雷达1002观测点B
            ★
        雷达1003观测点C
            ★

距离:
dist(A, B) = 0.05度 < 0.12度 ✓ 匹配
dist(A, C) = 0.15度 > 0.12度 ✗ 不匹配
dist(B, C) = 0.10度 < 0.12度 ✓ 匹配

匹配结果:
匹配组1: [点A, 点B, 点C]  (三个点都互相接近)
```

---

### 3.4 距离阈值说明

| 参数 | 默认值 | 说明 |
|------|--------|------|
| `MATCH_DISTANCE_THRESHOLD` | 0.12度 | 约等于 **13.3 km** (在赤道附近) |

**计算**:
```
0.12度 × 111 km/度 ≈ 13.3 km
```

这个阈值考虑了:
- 雷达测量误差
- 目标在两个采样时刻之间的移动
- 坐标系统误差

---

### 3.5 匹配统计示例

```python
# track_matcher.py:241-267
def analyze_match_statistics(matched_groups: List[List[Tuple]]) -> Dict[int, int]:
    """
    分析匹配统计信息

    Returns:
        字典：匹配组大小 -> 数量
        例如: {2: 1500, 3: 300, 4: 50}
              表示: 2个雷达的匹配组1500个
                     3个雷达的匹配组300个
                     4个雷达的匹配组50个
    """
    group_sizes = [len(group) for group in matched_groups]

    statistics = {}
    for size in range(2, max_size + 1):
        count = sum(1 for s in group_sizes if s == size)
        if count > 0:
            statistics[size] = count

    return statistics
```

**输出示例**:
```
匹配统计信息:
  大小 2: 15234 组  (2个雷达同时观测)
  大小 3: 3456 组   (3个雷达同时观测)
  大小 4: 567 组    (4个雷达同时观测)
  大小 5: 89 组     (5个雷达同时观测)
```

---

## 四、SQL表结构

### 4.1 数据库概述

**文件**: `allkeyPot.db` (默认名称)

**数据库类型**: SQLite

**表数量**: 2个表 (`rf_tb0`, `rf_tb1`)

---

### 4.2 表结构详解

#### 4.2.1 原始点表 (rf_tb0)

存储**原始关键航迹点**（未经插值）。

```sql
CREATE TABLE rf_tb0 (
    station_id INTEGER,      -- 雷达站号
    track_id INTEGER,        -- 航迹批号
    time_seconds REAL,       -- 时间(秒, 从00:00:00起算)
    longitude REAL,          -- 经度(十进制度)
    latitude REAL,           -- 纬度(十进制度)
    altitude REAL,           -- 高度(米)
    segment_index INTEGER    -- 航迹段索引
);
```

**字段说明**:

| 字段 | 类型 | 说明 | 示例 |
|------|------|------|------|
| `station_id` | INTEGER | 雷达站编号 | 1001, 1002, ... |
| `track_id` | INTEGER | 航迹批号 | 1, 2, 3, ... |
| `time_seconds` | REAL | 时间(秒) | 3600.5 = 01:00:00.5 |
| `longitude` | REAL | 经度 | 116.1234 |
| `latitude` | REAL | 纬度 | 39.5678 |
| `altitude` | REAL | 高度 | 5000.0 |
| `segment_index` | INTEGER | 航迹段序号 | 1, 2, 3, ... |

**示例数据**:

```
station_id | track_id | time_seconds | longitude | latitude | altitude | segment_index
-----------|----------|--------------|-----------|----------|----------|---------------
1001       | 1        | 3600.0       | 116.1234  | 39.5678  | 5000.0   | 1
1001       | 1        | 3601.0       | 116.1235  | 39.5679  | 5001.0   | 1
1002       | 2        | 3600.0       | 116.1236  | 39.5680  | 5002.0   | 2
1002       | 2        | 3602.0       | 116.1237  | 39.5681  | 5003.0   | 2
```

---

#### 4.2.2 插值点表 (rf_tb1)

存储**插值后的航迹点**。

```sql
CREATE TABLE rf_tb1 (
    station_id INTEGER,      -- 雷达站号
    track_id INTEGER,        -- 航迹批号
    time_seconds REAL,       -- 时间(秒)
    longitude REAL,          -- 经度(十进制度)
    latitude REAL,           -- 纬度(十进制度)
    altitude REAL,           -- 高度(米)
    segment_index INTEGER    -- 航迹段索引
);
```

**字段说明**: 与 `rf_tb0` 完全相同

**示例数据**:

```
station_id | track_id | time_seconds | longitude | latitude | altitude | segment_index
-----------|----------|--------------|-----------|----------|----------|---------------
1001       | 1        | 3600.0       | 116.1234  | 39.5678  | 5000.0   | 1
1001       | 1        | 3601.0       | 116.12345 | 39.56785 | 5000.5   | 1  ← 插值点
1001       | 1        | 3602.0       | 116.1235  | 39.5679  | 5001.0   | 1  ← 插值点
1001       | 1        | 3603.0       | 116.12355 | 39.56795 | 5001.5   | 1  ← 插值点
1001       | 1        | 3605.0       | 116.1236  | 39.5680  | 5002.0   | 1  ← 原始点
```

---

### 4.3 索引结构

为了加速查询，在两个字段上创建了索引:

```sql
-- 时间索引 (用于按时间查询)
CREATE INDEX idx_rf_tb0_time ON rf_tb0(time_seconds);
CREATE INDEX idx_rf_tb1_time ON rf_tb1(time_seconds);

-- 站号索引 (用于按雷达站查询)
CREATE INDEX idx_rf_tb0_station ON rf_tb0(station_id);
CREATE INDEX idx_rf_tb1_station ON rf_tb1(station_id);
```

**索引作用**:

1. `time_seconds` 索引: 加速按时间范围查询 (如 `WHERE time_seconds BETWEEN 3600 AND 7200`)
2. `station_id` 索引: 加速按雷达站查询 (如 `WHERE station_id = 1001`)

---

### 4.4 表之间的关系

```
                      原始航迹数据
                           │
                           ▼
                    ┌──────────────┐
                    │ track_       │
                    │ extractor.py │
                    └──────────────┘
                           │
           ┌───────────────┴───────────────┐
           ▼                               ▼
    ┌──────────────┐              ┌──────────────┐
    │   关键航迹段  │              │ track_       │
    │   (稀疏点)    │              │ interpolator │
    └──────────────┘              └──────────────┘
                                          │
                          ┌───────────────┴───────────────┐
                          ▼                               ▼
                   ┌──────────────┐              ┌──────────────┐
                   │   rf_tb0     │              │   rf_tb1     │
                   │  原始点表     │              │  插值点表     │
                   └──────────────┘              └──────────────┘
                          │                               │
                          └───────────────┬───────────────┘
                                          ▼
                                   ┌──────────────┐
                                   │ track_       │
                                   │ matcher.py   │
                                   └──────────────┘
                                          │
                                          ▼
                                   ┌──────────────┐
                                   │  匹配组       │
                                   │  error_calc  │
                                   └──────────────┘
```

---

### 4.5 数据查询示例

```sql
-- 查询某个雷达站在某个时间范围的所有原始点
SELECT * FROM rf_tb0
WHERE station_id = 1001
  AND time_seconds BETWEEN 3600 AND 7200
ORDER BY time_seconds;

-- 查询所有航迹段的数量
SELECT segment_index, COUNT(*) as count
FROM rf_tb0
GROUP BY segment_index
ORDER BY segment_index;

-- 查询每个雷达站的数据量
SELECT station_id, COUNT(*) as count
FROM rf_tb0
GROUP BY station_id
ORDER BY station_id;

-- 联合查询原始点和插值点
SELECT
    o.station_id,
    o.track_id,
    o.time_seconds as orig_time,
    i.time_seconds as interp_time,
    o.longitude as orig_lon,
    i.longitude as interp_lon
FROM rf_tb0 o
JOIN rf_tb1 i ON o.station_id = i.station_id
             AND o.track_id = i.track_id
             AND ABS(o.time_seconds - i.time_seconds) < 1.0;
```

---

### 4.6 数据规模估算

假设:
- 5个雷达站
- 每个雷达每天100条航迹
- 每条航迹平均50个关键点
- 插值后每个点间隔1秒

```
原始点表 (rf_tb0):
5 × 100 × 50 = 25,000 条记录

插值点表 (rf_tb1):
假设每条航迹持续300秒 (5分钟)
5 × 100 × 300 = 150,000 条记录

总计: 175,000 条记录/天
```

---

## 五、总结

### 5.1 三个核心模块的关系

```
┌──────────────────┐
│ 关键航迹提取      │ → 输入: 原始航迹数据
│ track_extractor  │   输出: 稀疏的关键航迹段
└──────────────────┘
         │
         ▼
┌──────────────────┐
│ 航迹插值存储      │ → 输入: 关键航迹段
│ track_interpolator│   输出: 密集的插值点 (存入DB)
└──────────────────┘
         │
         ▼
┌──────────────────┐
│ 航迹匹配          │ → 输入: 原始点表 + 插值点表
│ track_matcher    │   输出: 匹配组列表
└──────────────────┘
         │
         ▼
┌──────────────────┐
│ 误差计算          │ → 输入: 匹配组 + 雷达位置
│ error_calculator │   输出: 各雷达的系统误差
└──────────────────┘
```

### 5.2 关键技术点

| 模块 | 关键技术 | 目的 |
|------|----------|------|
| 关键航迹提取 | 空间网格 + 时间窗口 + 3×3邻域检测 | 过滤噪声，提取稳定航迹 |
| 航迹插值存储 | 线性插值 + SQLite数据库 | 时间对齐，增加匹配机会 |
| 航迹匹配 | 空间距离阈值 + 同站号排除 | 找出同一目标的多雷达观测 |
